\chapter{Life-Cycle Models}
\section{Overview}
Life-cycle models are a simplified representation of a software process. Each process model represents a process from a particular perspective and thus only provides partial information about that process. For example, a process activity model shows the activities and their sequence but may not show the roles of the people involved in these activities.

The generic models are high-level, abstract descriptions of software processes that can be used to explain different approaches to software development. They can be seen as process frameworks that may be extended and adapted to create more specific software engineering processes. The general process models that exist are:

\begin{enumerate}
    \item The waterfall model: This takes the fundamental process activities of specification, development, validation and evolution and represents them as separate process phases such as requirements specification, software design, implementation and testing.
    \item Incremental development: This approach interleaves the activities of specification, development and validation. The system is developed as a series of versions (increments), with each version adding functionality to the previous version.
    \item Integration and configuration: This approach relies on the availabitlity of reusable components or systems. The system development process focuses on configuring these components for use in a new setting and integrating them into a system.
\end{enumerate}

There is no universal process model that is right for all kinds of software development. The right process depends on the customer and regulatory requirements, the environment where the software will be used, and the type of software being developed. For example, safety-critical software is usually developed using a waterfall process as lots of analysis and documentation is required before implementation begins. Software products are now always developed using an incremental process model. Business systems are increasingly being developed by configuring existing systems and integrating these to create a new system with the functionality that is required.

The majority of practical software processes are based on a general model but often incorporate features of other models. This is particularily true for large systems engineering. For large system, it makes sense to combine osme of the best features of all of the general processes. We need to have information about the essential system requriements to design a software architecture to support these requriements. It is impossible to develop that incrementally. Subsystems within a larger system may be developed using different approaches.

Various attempts have been made to develop "universal" process models that draw on all of these general models. One of the best known of these universal models is the Rational Unified Process (RUP), which was developed by Rational, a U.S. software engineering company. The RUP is a flexible model that can be instantiated in different ways to create processes that resemble any of the general process models we've seen.

\section{The Waterfall Model}
The first published model of the software development process was derived from engineering process models used in large military systems engineering. It presents the software development process as a number of stages. Because of the cascade from one phase to another, this model is known as the waterfall model. The waterfall model is an example of a plan-driven process. In principle at least, all of the process activities are planned and scheduled before starting the software development.

THe stages of the waterfall model directly reflect the fundamental software development activities:
\begin{enumerate}
    \item Requirements analysis and definition: The system's services, constraints, and goals are established by consultation with system users. They are then defined in detail and serve as a system specification.
    \item System and software design: The systems design process allocates the requirements to either hardware or software systems. It establishes an overall system architecture. Software design involves identifying and describing the fundamental software system abstractions and their relationships.
    \item Implementation and unit testing: During this stage, the software design is realized as a set of programs or program units. Unit testing involves verifying that each unit meets its specification.
    \item Integration and system testing: The individual program units or programs are integrated and tested as a complete system to ensure that the software requirements have been met. After testing, the software system is delivered to the customer.
    \item Operation and maintenance: Normally, this is the longest life-cycle phase. The system is installed and put into practical use. Maintenant involves correcting errors that were not discovered in earlier stages of the life cycle, improving the implementation of system units, and enhancing the system's services as new requirements are discovered.
\end{enumerate}

In principle, the result of each phase of the waterfall model is one or more documents that are approved. The following phase should not start until the previous phase has finished. For hardware development, where high manufacturing costs are invovled, this makes sense. However, for software development, these stages overlap and feed information to each other. During design, problems with requirements are identified; during coding design problems are found, and so on. The software process, in practice, is never a simple linear model but involves feed-back from one phase to another.

In reality, software has to be flexible and accommodate change as it is being developed. The need for early commitment and system rework when changes are made means that the waterfall model is only apprapriate for some types of system:
\begin{enumerate}
    \item Embedded systems where the software has to interface with hardware systems. Because of the inflexibitlity of hardware, it is not usually possible to delay decisions on the software's functionality until it is being implemented.
    \item Critical systems where there is a need for extensive safety and security analysis of the software specification and design. In these systems, the specification and design documents must be complete so that this analysis is possible. Safety-related problems in the specification are usually very expensive to correct at the implementaion stage.
    \item Large software systems that are part of broader engineering systems developed by several partner companies. The hardware in the systems may be developed using a similar model, and companies find it easier to use a common model for hardware and software. Furthermore, where several companies are involved, complete specifications may be needed to allow for the independent development of different subsystems.
\end{enumerate}

The waterfall model is not hte right process model in situations where informal team communication is possible and software requirements change quickly. Iterative development and agile methods are better for these systems.

An important variant of the waterfall model is formal system development, where a mathematical model of a system specification is created. This model is then refined, using mathematical transformations that preserve its consistency, into executable code. The formal apprach simplifies the production of a safety or security case. This demonstrates to customers or regulators that the system actually meets its safety and security requirements. However, because of the high costs of developing a formal specification, this development model is rarely used except for critical systems engineering.

\section{Incremental development}
Incremental development is based on the idea of developing an initial implementation, getting feedback from  users and others, and evolving the software through several versions until the required system has been developed. Specification, development and validation activities are interleaved rather than separate, with rapid feedback across activities.

Incremental development in some form is now the most common apprach for the development of application systems and software products. This approach can be either plan-driven, agile or, more usually, a mixture of these approaches. In a plan-driven approach, the systems increments are identified in advance; if an agile approach is adopted, the early increments are identified, but the development of later increments depends on progress and customer priorities.

Incremental software development, which is a fundamental part of agile development methods, is better than a waterfall approach for systems whose requirements are likely to change during the development process. This is the case for most business systems and software products. Incremental development reflects the way that we solve problems. We rarely work out a complete problem solution in advance but move toward a solution in a series of steps, back-tracking when we realize that we have made a mistake. By developing the software incrementally, it is cheaper and easier to make changes in the software as it is being developed.