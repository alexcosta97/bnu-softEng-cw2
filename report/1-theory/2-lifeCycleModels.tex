\chapter{Life-Cycle Models}
\section{Overview}
Life-cycle models are a simplified representation of a software process. Each process model represents a process from a particular perspective and thus only provides partial information about that process. For example, a process activity model shows the activities and their sequence but may not show the roles of the people involved in these activities.

The generic models are high-level, abstract descriptions of software processes that can be used to explain different approaches to software development. They can be seen as process frameworks that may be extended and adapted to create more specific software engineering processes. The general process models that exist are:

\begin{enumerate}
    \item The waterfall model: This takes the fundamental process activities of specification, development, validation and evolution and represents them as separate process phases such as requirements specification, software design, implementation and testing.
    \item Incremental development: This approach interleaves the activities of specification, development and validation. The system is developed as a series of versions (increments), with each version adding functionality to the previous version.
    \item Integration and configuration: This approach relies on the availabitlity of reusable components or systems. The system development process focuses on configuring these components for use in a new setting and integrating them into a system.
\end{enumerate}

There is no universal process model that is right for all kinds of software development. The right process depends on the customer and regulatory requirements, the environment where the software will be used, and the type of software being developed. For example, safety-critical software is usually developed using a waterfall process as lots of analysis and documentation is required before implementation begins. Software products are now always developed using an incremental process model. Business systems are increasingly being developed by configuring existing systems and integrating these to create a new system with the functionality that is required.

The majority of practical software processes are based on a general model but often incorporate features of other models. This is particularily true for large systems engineering. For large system, it makes sense to combine osme of the best features of all of the general processes. We need to have information about the essential system requriements to design a software architecture to support these requriements. It is impossible to develop that incrementally. Subsystems within a larger system may be developed using different approaches.

Various attempts have been made to develop "universal" process models that draw on all of these general models. One of the best known of these universal models is the Rational Unified Process (RUP), which was developed by Rational, a U.S. software engineering company. The RUP is a flexible model that can be instantiated in different ways to create processes that resemble any of the general process models we've seen.

\section{The Waterfall Model}
The first published model of the software development process was derived from engineering process models used in large military systems engineering. It presents the software development process as a number of stages. Because of the cascade from one phase to another, this model is known as the waterfall model. The waterfall model is an example of a plan-driven process. In principle at least, all of the process activities are planned and scheduled before starting the software development.

THe stages of the waterfall model directly reflect the fundamental software development activities:
\begin{enumerate}
    \item Requirements analysis and definition: The system's services, constraints, and goals are established by consultation with system users. They are then defined in detail and serve as a system specification.
    \item System and software design: The systems design process allocates the requirements to either hardware or software systems. It establishes an overall system architecture. Software design involves identifying and describing the fundamental software system abstractions and their relationships.
    \item Implementation and unit testing: During this stage, the software design is realized as a set of programs or program units. Unit testing involves verifying that each unit meets its specification.
    \item Integration and system testing: The individual program units or programs are integrated and tested as a complete system to ensure that the software requirements have been met. After testing, the software system is delivered to the customer.
    \item Operation and maintenance: Normally, this is the longest life-cycle phase. The system is installed and put into practical use. Maintenant involves correcting errors that were not discovered in earlier stages of the life cycle, improving the implementation of system units, and enhancing the system's services as new requirements are discovered.
\end{enumerate}

In principle, the result of each phase of the waterfall model is one or more documents that are approved. The following phase should not start until the previous phase has finished. For hardware development, where high manufacturing costs are invovled, this makes sense. However, for software development, these stages overlap and feed information to each other. During design, problems with requirements are identified; during coding design problems are found, and so on. The software process, in practice, is never a simple linear model but involves feed-back from one phase to another.

In reality, software has to be flexible and accommodate change as it is being developed. The need for early commitment and system rework when changes are made means that the waterfall model is only apprapriate for some types of system:
\begin{enumerate}
    \item Embedded systems where the software has to interface with hardware systems. Because of the inflexibitlity of hardware, it is not usually possible to delay decisions on the software's functionality until it is being implemented.
    \item Critical systems where there is a need for extensive safety and security analysis of the software specification and design. In these systems, the specification and design documents must be complete so that this analysis is possible. Safety-related problems in the specification are usually very expensive to correct at the implementaion stage.
    \item Large software systems that are part of broader engineering systems developed by several partner companies. The hardware in the systems may be developed using a similar model, and companies find it easier to use a common model for hardware and software. Furthermore, where several companies are involved, complete specifications may be needed to allow for the independent development of different subsystems.
\end{enumerate}

The waterfall model is not hte right process model in situations where informal team communication is possible and software requirements change quickly. Iterative development and agile methods are better for these systems.

An important variant of the waterfall model is formal system development, where a mathematical model of a system specification is created. This model is then refined, using mathematical transformations that preserve its consistency, into executable code. The formal apprach simplifies the production of a safety or security case. This demonstrates to customers or regulators that the system actually meets its safety and security requirements. However, because of the high costs of developing a formal specification, this development model is rarely used except for critical systems engineering.

\section{Incremental development}
Incremental development is based on the idea of developing an initial implementation, getting feedback from  users and others, and evolving the software through several versions until the required system has been developed. Specification, development and validation activities are interleaved rather than separate, with rapid feedback across activities.

Incremental development in some form is now the most common apprach for the development of application systems and software products. This approach can be either plan-driven, agile or, more usually, a mixture of these approaches. In a plan-driven approach, the systems increments are identified in advance; if an agile approach is adopted, the early increments are identified, but the development of later increments depends on progress and customer priorities.

Incremental software development, which is a fundamental part of agile development methods, is better than a waterfall approach for systems whose requirements are likely to change during the development process. This is the case for most business systems and software products. Incremental development reflects the way that we solve problems. We rarely work out a complete problem solution in advance but move toward a solution in a series of steps, back-tracking when we realize that we have made a mistake. By developing the software incrementally, it is cheaper and easier to make changes in the software as it is being developed.

Each increment or version of the system incorporates some of the functionality that is needed by the sustomer. Generally, the early increments of the system include the most important or most urgently required functionality. This means that the customer or user can evaluate the system at a relatively early stage in the development to see if it delivers what is required. If not, then only the current increment has to be changed, and possibly, new functionality defined in later increments.

Incremental development has three major advantages over the waterfall model:
\begin{enumerate}
    \item The cost of implementing requirements changes is reduced. The amount of analysis and documentation that has to be redone is significantly less than is required with the waterfall model.
    \item It is easier to get customer feedback on the development work that has been done. Customers can comment on demonstrations of the software and see how much has been implemented.. Customers find it difficult to judge progress from software design documents.
    \item Early delivery and deployment of useful software to the customer is possible, even if all of the functionality has not been included. Customers are able to use and gain value from the software earlier than is possible with a waterfall process.
\end{enumerate}

From a management perspective, the incremental approach has two problems:
\begin{enumerate}
    \item The process is not visible. Managers need regular deliverables to measure progress. If systems are developed quickly, it is not cost effective to produce documents that reflect every version of the system.
    \item System structure tends to degrade as new increments are added. Regular change leads to messy code as new functionality is added in whatever way is possible. It becomes increasingly difficult and costly to add new features to a system. To reduce structural degradation and general code messiness, agile methods suggest that you should regularly refactor (improve and restructure) the software.
\end{enumerate}

The problems of incremental develoment become particularly acute for large, complex, long-lifetime systems, where different teams develop different parts of the system. Large systems need a stable framework or architecture, and the reposibilities of the different teams working on parts of the system need to be clearly defined with respect to that architecture. This has to be planned in advance rather than developed incrementally.

Incremental development does not mean that each increment has to be delivered to the system customer. The system can be developed incrementally and exposed to customers and other stakeholders for comment, without necessarily delivering it and deploying it in the customer's environment. Incremental delivery means that the software is used in real, operational processes, so user feedback is likely to be realistic. However, providing feedback is not always possible as experimenting with new software can disrupt normal business processes.

\section{Integration and configuration}
In the majority of software projects, there is some software reuse. This often happens informally when people working on the project know of or search for code that is similar to what is required. They look for these, modify them as needed, and integrate them with the new code that they have developed.

This informal reuse takes place regardless of the development process that is used. However, since 2000, software development processes that focus on the reuse of existing software have become widely used. Reuse-oriented approaches rely on a base of reusable software components and an integrating framework for the composition of these components. Three types of software components are frequently reused:
\begin{enumerate}
    \item Stand-alone application systems that are configured for use in a particular environment. These systems are general-purpose systems that have many features but they have to be adapted for use in a specific application
    \item Collections of objects that are developed as a component or as a package to be integrated with a component framework
    \item Web services that are developed according to service standards and that are available for remote invocation over the Internet.
\end{enumerate}

A general process model for the integration and configuration approach would be the following:
\begin{enumerate}
    \item Requirements specification: The initial requirements for the system are proposed. These do not have to be elaborated in detail but should include brief descriptions of essential requirements and desirable system features
    \item Software discovery and evaluation: Given an outline of the software requirements, a search is made for components and systems that provide the functionality required. Candidate componenets and systems are evaluated to see if they meet the essential requirements and if they are generally suitable for use in the system.
    \item Requirements refinement: During this stage, the requirements are refined using information abotu the reusable components and applications that have been discoered. The requirements are modified to reflect the available components, and the system specification is re-defined. Where modificatoins are impossible, the component analysis activity may be reentered to search for alternative solutions.
    \item Application system configuration: If an off-the-shelf application that meets the requirements is available, it may then be configured for use to create the new system.
    \item Component adaptation and integration: If there is no off-the-shelf system, individual reusable components may be modified and new components developed. These are then integrated to create the system.
\end{enumerate}

Reuse-oriented software engineering, based around configuration and integration, has the obvious advantage of reducing the amount of software to be developed and so reducing cost and risks. It usually also leads to faster delivery of the software. However, requriements compromises are inevetable, and this may lead to a system that does not meet the real needs of users. Furthermore, some control over the system evolution is lost as new versions of the reusable components are not under the control of the organization using them.